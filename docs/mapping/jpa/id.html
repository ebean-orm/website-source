<html>
<head>
  <meta name="layout" content="_layout2/base-mapping-jpa.html"/>
  <meta name="bread3" content="@Id" href="/docs/mapping/id"/>
<#assign id = "true">
</head>
<body>

<h2 id="id">@Id</h2>
<p>
  Mark a property as the <code>@Id</code> property.
</p>
<pre content="java">
@Entity
public class Contact {

  @Id
  long id;

  ...
}
</pre>

<h2 id="generated-value">@GeneratedValue</h2>
<p>
  When we annotate a property with <code>@Id</code> Ebean will automatically assign an appropriate
  <code>Id generator</code> if the type <code>is a number type or UUID type</code>.
</p>
<p>
  That is, with Ebean it is effectively redundant to also add the <code>@GeneratedValue</code> annotation.
</p>
<p>
  This behaviour can be disabled using idGeneratorAutomatic configuration property.
</p>
<pre content="java">
  @Id
  long id;

  // ... is effectively the same as

  @Id @GeneratedValue
  long id;
</pre>


<h2 id="idGeneratorAutomatic">idGeneratorAutomatic</h2>
<p>
  We can disable the automatic generation of Id values by configuring
  <code>idGeneratorAutomatic</code> to be <code>false</code>.
</p>
<p>
  configure via properties:
</p>
<pre content="properties">
  ebean.idGeneratorAutomatic=false
</pre>
<p>
  configure via code:
</p>
<pre content="java">
  DatabaseConfig.setIdGeneratorAutomatic(false)
</pre>
<p>
  With idGeneratorAutomatic disabled then we need to explicitly add the
  <code>@GeneratedValue</code> to every <code>@Id</code> property that
  we want to have generated values via Database Identity or Sequence.
</p>
<p>
  Alternatively we can use <a href="/docs/mapping/extensions/identity#application">@Identity</a>
  with <code>type=APPLICATION</code> to explicitly specify that the id value
  will be supplied by the application.
</p>

<h2 id="identity">@Identity</h2>
<p>
  Ebean additionally has an <a href="/docs/mapping/extensions/identity">@Identity</a> annotation
  when we want to use to specify the <code>starts value</code>, <code>cache value</code> and
  <code>generated by default|always</code> options for database identity or sequence.
</p>
<p>
  We want to use this to specifically set the <code>cache</code> option when the associated
  table is expected to get a high load of inserts and we want to let databases that support it
  to have higher than normal id caching to reduce contention around generated id values/sequences.
  Postgres, Oracle and NuoDB all support setting the identity cache option. The downside to larger
  cache for id values is the potential for larger gaps in the id values if the database is restarted.
</p>
<pre content="java">
  @Id @Identity(start=10000, cache=500)
  long id;
</pre>
<p>
  We can also specify <code>@Identity</code> on the class - typically when the id property
  is inherited from a MappedSuperclass.
</p>
<pre content="java">
@Entity
@Identity(start=10000, cache=500)
public class Contact {

  @Id
  long id;

  ...
}
</pre>

<h2 id="uuid">UUID</h2>
<p>
  If the <em>@Id</em> type is <code>UUID</code> then Ebean will automatically assign an appropriate Id generator
  to that property.
</p>
<pre content="java">
// an appropriate UUID based Id generator
// is automatically assigned
@Id
UUID id;
</pre>

<h2 id="uuid-generatedValue">UUID and @GeneratedValue</h2>
<p>
  If we have a <code>UUID</code> that is <b>NOT</b> the <em>@Id</em> we can add <code>@GeneratedValue</code> and
  then Ebean will assign a appropriate UUID generator to it.
</p>
<pre content="java">
  /** The Id property using DB Identity or Sequence */
  @Id @GeneratedValue
  private long id;

  /** Alternate unique UUID property */
  @GeneratedValue @Column(unique = true)
  private UUID uid;
</pre>

<h2 id="string">String</h2>
<p>
  If the @Id type is <code>String</code> then Ebean assumes that the id value is supplied by the
  application. No Id generator is assigned to the Id property in this case.
</p>

<pre content="java">
@Id
String code;
</pre>
<p>
  An example of this could be ISO Country codes used as a primary key for Country.
</p>

<h2 id="no-id">Entities with no @Id property</h2>
<p>
  We can model entity beans without any <code>@Id</code> property. The 2 cases for this are
  when modelling views and when modelling tables that are "insert only" representing a log
  of events or similar.
</p>
<h3>Views</h3>
<p>
  When the entity bean is modelled to a <code>@View</code> often the view will not have
  column(s) that equates to a primary key.
</p>
<h5>Example - entity based on a view with @Id property</h5>
<pre content="java">
@Entity
@View(name = "machine_stats")
public class MachineStats {

  @ManyToOne
  Machine machine;

  LocalDate date;

  @Sum  // equivalent to @Aggregation("sum(totalKms)")
  long totalKms;

  @Sum
  long hours;

  @Max
  BigDecimal rate;

  @Aggregation("sum(cost)")
  BigDecimal totalCost;

  @Aggregation("max(totalKms)")
  BigDecimal maxKms;
</pre>
<h3>Tables with no primary key</h3>
<p>
  When modelling a "append only" table where we do not <em>need</em> a primary key
  then we can desire not having an <code>@Id</code> property and no actual primary key.
  We can desire this when we want to avoid the cost of the primary key index (that the
  application will never need or use).
</p>
<p>
  For Postgres we would often use table partitioning for this type of "append only" events
  type table via <code>@DbPartition</code>.
</p>

<h5>Example - append only table with no primary key / no @Id property</h5>
<pre content="java">
/**
 * Append only table with no Id property, no primary key (no primary key index).
 */
@DbPartition(mode = DAY, property = "eventTime")
@Entity
@Table(name = "machine_log")
public class MachineLog {

  @Index
  @NotNull
  protected Instant eventTime;

  @DbForeignKey(noConstraint = true)
  @ManyToOne(optional = false)
  protected Machine machine;

  ...
</pre>

<h2 id="custom">Custom Id Generator</h2>
<p>
  There is support for registering and using a custom Id generator.
</p>

<h4>1. Implement io.ebean.config.IdGenerator</h4>
```java
public class ModUuidGenerator implements IdGenerator {

  @Override
  public Object nextValue() {
    return ModUUID.newShortId();
  }

  @Override
  public String getName() {
    return "shortUid";
  }
}
```
<h4>2. Register with ServerConfig</h4>
<p>
  We register the IdGenerator with ServerConfig by using <code>addClass()</code>
  or <code>add(IdGenerator idGenerator)</code> or <code>setIdGenerators(List<IdGenerator> idGenerators)</code>.
</p>
<p>
  Note that if you are using classpath scanning to find entity beans that this will also automatically
  find implementations of IdGenerator and automatically register them so in this case you don't need to
  register the IdGenerator manually with ServerConfig.
</p>

<h4>3. @GeneratedValue</h4>
<p>
  We can then tell Ebean to use our custom IdGenerator by using the <code>@GeneratedValue</code> with
  the generator being the name of our custom IdGenerator.
</p>
```java
  @Id @GeneratedValue(generator = "shortUid")
  String id;
```

<h2 id="no-lazy-loading">No lazy loading</h2>
<p>
  Note that <code>@Id</code> properties never invoke lazy loading.
</p>

<h2 id="database-platform">Database platform</h2>
<p>
  All the supported databases use either <code>Identity</code> or <code>Sequences</code> (or allow both)
  and Ebean will choose the appropriate Id generation strategy based on the database platform.
</p>
<table class="table">
  <tr><th>Database</th><th>Strategy</th></tr>
  <tr><td>H2</td><td>Identity (also supports sequences)</td></tr>
  <tr><td>Postgres</td><td>Identity (as serial, also supports sequences)</td></tr>
  <tr><td>MySql</td><td>Identity</td></tr>
  <tr><td>Oracle</td><td>Sequences (also supports Identity)</td></tr>
  <tr><td>DB2</td><td>Identity (also supports sequences)</td></tr>
  <tr><td>SQL Server</td><td>Identity</td></tr>
  <tr><td>SQLite</td><td>Identity</td></tr>
  <tr><td>SqlAnywhere</td><td>Identity</td></tr>
</table>

<@next_edit "Version" "version" "/docs/mapping/jpa/id.html"/>

</body>
</html>
